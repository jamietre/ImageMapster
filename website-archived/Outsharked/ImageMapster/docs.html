<div>
<h1>Using ImageMapster</h1>

<h2></h2>
<div id="wiki-content" style="font-size: 14px;">
  <div class="wrap">
  <div id="wiki-body" class="gollum-markdown-content instapaper_body">
    <div id="template">
<div style="padding-right:40px;">
<p>
    <b>New!</b> Please see this <a href="http://www.dezynetek.com/AbsoluteBeginners/beginner1.htm">introduction to ImageMapster for absolute beginners</a>. This is a great
    place to start if you are a novice with JavaScript and jQuery.

</p>
<p>
If you haven't already, download the script and include it in your page:
</p>
<pre class="myprettyprint">    &lt;script type="text/javascript" src="scripts/jquery.imagemapster.js"&gt;&lt;script&gt;</pre>


<p>To activate all <a href="http://en.wikipedia.org/wiki/Image_map" target="_blank">image maps</a> on the page with 
the default options, just add this inside a <a target="_blank" href="http://www.scriptingmaster.com/javascript/JavaScript-script-block.asp">script block</a>:</p>

<pre class="myprettyprint">    $('img').mapster();</pre>

Usually, you'll want to target a specific image by id, and maybe define some options for how the areas should
appear when highlighted. You do this by passing an object with options when you bind the image:

<pre class="myprettyprint">    $('#myimage').mapster({
        fillColor: 'ff0000',
        fillOpacity: 0.3
    });</pre>

Once bound, in addition to responding to click events, you can manipulate the effects from Javascript. This would
choose all <code>area</code> elements that had a class <code>group1</code> and cause them to become selected, as if they'd
been clicked by the user:

<pre class="myprettyprint">    $('area.group1').mapster('set',true);</pre>

You can also define your own keys to identify areas and group them together. Keys are just a value of an attribute on
each area. You tell ImageMapster the name of this attribute with the <code>mapKey</code> option, and then you can identify
areas or groups of areas by key:

<pre class="myprettyprint">    // an imagemap of the U.S.A

    &lt;img src="..." usemap="#mymap"&gt;
    &lt;map name="mymap"&gt;
         &lt;area data-key="AZ" href="#" coords="..." /&gt;
         &lt;area data-key="AK" href="#" coords="..." /&gt;
         &lt;area data-key="AR" href="#" coords="..."/&gt;
         &lt;area data-key="AL" href="#" coords="..." /&gt;
         &lt;area data-key="CO" href="#" coords="..." /&gt;
         ...
    &lt;/map&gt;
    
    // bind using "data-key" as a mapKey, and select four states

    $('#myimage')
        .mapster({
            mapKey: 'data-key'
        })
        .mapster('set',true,'AK,AZ,AR,AL');</pre>

There are a lot more options you can use to control how things appear. Keep reading!

<h4>Terminology</h4>
<p>For many of the concepts and functionality described below, it will help to explain the basic 
terminology used:</p>
<ul>
<li><i>area</i> - an area on an image map, specifically, defined by an <code>area</code> tag in the HTML markup. </li>
<li><i>area group</i> - one or more areas that are grouped together logically, each defined by an <code>area</code> tag. Area groups can be manipulated as if they were a single area.
Often when discussing functionality I may use "area" and "area group" interchangeably. In most cases, functionality applies an area group, which can be one or more areas. 
If the distinction is important, though, I will probably say "a specific area."
</li>
<li><i>map key</i> - a token used to identify an area or group. While you can use ImageMapster to manipulate things by selecting actual <code>area</code> 
elements from your HTML, it is often more convenient to refer to an area group. The <a href="#mapkey"><code>map key</code></a> refers to an identifier that you provide
for each area, which also creates groups (when you use the same identifier for multiple areas). If you don't want to create any groups and don't want to refer
to areas other than via their HTML tags, you do not have to provide a map key.</li>
<li><i>primary key</i> - an area can contain more than one key in the attribute identified by <code>mapKey</code>, separated by commas.
The first one is the <i>primary key</i> and defines what areas are higlighted together when an area is clicked.
However, you can add more keys to create other groupings, which can be activated using the <code>set</code> method.</li>
<li><i>select</i> - when you select something, it becomes active until deselected. Selecting is like checking a box. It remains selected until deselected.</li>
<li><i>highlight</i> - a highlight, unlike a selection, is temporary, and can only apply to a single area at once. Usually something is highlighted when the user
moves their mouse pointer over it, but a highlight can be set programatically as well.</li>
<li><i>static state</i> - areas may also be "static state" which means that their selection state cannot be changed. A static state can either be true or false;
when true, an area appears selected, but can never be deselected. Static state <i>does not affect selection state.</i> When querying the state of a static state area,
even if it appears selected (because it's static state is true), it's selection stae will always be false. 
</ul>
</div>
<h4>Methods</h4>
<ul>
    <li><a href="#select"><code>select</code></a> - cause an area to become selected or active</li>
    <li><a href="#deselect"><code>deselect</code></a> - cause an area to become deselected or inactive</li>
    <li><a href="#set"><code>set</code></a> - select, deselect, or toggle the state of an area or areas</li>
    <li><a href="#get"><code>get</code></a> - return the selected state of an area, or a list of all selected areas</li>
    <li><a href="#highlight"><code>highlight</code></a> - set or clear the highlighted area, or return highlighted area</li>
    <li><a href="#unbind"><code>unbind</code></a> - remove ImageMapster bindings, restore everything to it's original state</li>
    <li><a href="#snapshot"><code>snapshot</code></a> - remove ImageMapster bindings, but leave appearance unchanged</li>
    <li><a href="#rebind"><code>rebind</code></a> - update options and redraw the imagemap using the new options</li>
    <li><a href="#resize"><code>resize</code></a> - change the size of a bound image and image map</li>
    <li><a href="#keys"><code>keys</code></a> - get the map keys for an area, areas or key group</li>
    <li><a href="#set_options"><code>set_options</code></a> - change options without redrawing</li>
    <li><a href="#get_options"><code>get_options</code></a> - get current or effective options for a bound image map</li>
    <li><a href="#tooltip"><code>tooltip</code></a> - show or hide tooltips</li>
</ul>
<div class="optionMap">
<h4>Options</h4>

The following are global options. Each option has the default value in bold, and other possible values separated by a pipe | character.
If the value is a type (e.g. boolean, function) then any valid value for that type is acceptable.


<ul>
    <li><code><a href="#mapkey">mapKey</a>: <b>''</b> | string</code><br />the name of an attribute found on <code>area</code> HTML elements used to identify it for any future operations, 
    and to create groups of areas that function together. When not assigned, all hotspots are activated as unique areas</li>
    <li><code><a href="#mapvalue">mapValue</a>: <b>''</b> | string</code><br />the name of an attribute found on <code>area</code> HTML elements used to identify it for any future operations, 
    and to create groups of areas that function together</li>
    <li><code><a href="#clicknavigate">clickNavigate</a>: <b>false</b> | true</code>
    <br />Clicking on a link should cause the browser to navigate to the <code>href</code> whenever it's not a hash sign (#).</li> 
    
    <li><code><a href="#listkey">listKey</a>: <b>''</b> | string</code><br />an attribute found on elements in a <em>boundList</em> that corresponds to the value of the <em>mapKey</em> attributes.</li>
    <li><code><a href="#listselectedattribute">listSelectedAttribute</a>: <b>'selected'</b> | string</code><br />a boolean attribute that will be added or removed from list target elements when its corresponding map area is selected or deselected.
    <li><code><a href="#listselectedclass">listSelectedClass</a>: <b>null</b> | string</code><br />a CSS class name that will be toggled on a list target elements when its corresponding map area is selected or deselected.

    <li><code><a href="#areas">areas</a>: [{}, {}, ...]</code><br />define area-specific options; each object in the array must contain a "key" 
        property identifying a valid mapKey, and additional rendering options specific to that area or group</li>

    <li><code><a href="#singleselect">singleSelect</a>: <b>false</b> | true</code> (milliseconds)<br />delay before removing highlight after mouse leaves an area</li>
   
    <li><code>wrapClass: <b>null</b> | classname | true</code><br />add "classname" class to the wrapper created around the image, or copy classes from the image if "true"</li>
    <li><code>wrapCss: <b>null</b> | classname | true</code><br />add CSS to the wrapper created around the image</li>
    <li><code><a href="#mouseoutdelay">mouseoutDelay</a>: <b>0</b> | -1 | n</code> (milliseconds)<br />delay before removing highlight after mouse leaves an area</li>
    <li><code><a href="#sortlist">sortList</a>: <b>true</b> | false</code><br />when true, sort onGetList data by <code>mapValue</code> key </li>
    <li><code><a href="#configtimeout">configTimeout</a>: <b>10000</b> | integer</code><br />
        Time in milliseconds to wait for images to load</li>
    <li><code><a href="#scalemap">scaleMap</a>: <b>true</b> | false</code><br />
        Automatically scale image maps to the display size of the image
    </li>
     <li><code><a href="#nohrefismask">noHrefIsMask</a>: <b>true</b></code><br />
        Treat areas with a <code>nohref</code> attribute as masks: if they fall within another area, they will be excluded from the group.</li>
       <li><code><a href="#boundlist">boundList</a>: <b>null</b> | jQuery object</code><br />
       A list of objects bound to the imagemap that will be updated when areas are selected or deselected
       </li>
</ul>
<h4>Rendering Options</h4>
<p>
The following are <i>rendering</i> options. Each option has the default global value, and can also be set 
on a per-area basis using <em>areas</em> option.

In additon, rendering options can be set individually for the highlight or select effect, by including them i
n special option object <code>render_select</code> and <code>render_highlight</code>. That is,
if you put one of these options inside an option called "render_highlight", it will only apply to
the highlight effect. You can also put theeffect-specific options into  an area-specific option.
</p>
<p>For example, this code will cause the <b>stroke</b> effect for both highlights & selections using the default
stroke width for selections, and a stroke width of 2 for highlights, for all areas. For the specific area 
with key "somearea", the stroke is disabled, and for selections only, the fill opacity is 1 
(completely opaque) for that area. Finally, for another area with key "someotherarea", the fill effect is
disabled, so only the stroke effect which was previously defined globally would apply. 
</p>
<pre class="prettyprint">
   $(img).mapster({
        stroke: true,
        render_highlight: {
            strokeWidth: 2
        },
        areas: [{
            key: 'somearea',
            stroke: false,
            render_select: { 
                fillOpacity: 1 
            }
        },
        { 
            key: 'someotherarea',
            fill: false
        }]
    });
</pre>

would cause the <em>stroke</em> effect to apply to both rendering and highlighting; the <em>strokeWidth</em> to be the default value (1) for selecting,
and 2 for highlighting, and the <em>fillOpacity</em> to be 1 only for theselection effect, only in the area or group "somearea."


<ul>
    <li><code><a href="#fade">fade</a>: true | false</code><br />fade effect - can only be applied to "render_highlight".</li>
    <li>fadeDuration: 150</li>
    <li><code><a href="#highlight">highlight:</a> <b>null</b> | true | false</code><br />
    highlight areas on mouseover. When null (default), the behavior is disabled for mobile browsers. 
    You can explicitly enable or disable it by setting this option to a boolean value.
    <li><code><a href="#staticstate">staticState</a>: <b>null</b> | true | false</code><br />
    set an area or the entire map to be permanently selected or permanently deselected</li>
    <li><code><a href="#staticstate">selected</a>: <b>false</b> | true</code><br />
        Set an area to be initially selected.</li>
    <li><code><a href="#isselectable">isSelectable</a>: <b>true</b> | false</code><br />
        Allow an area to be click-selected. When false, an area will still highlight but cannot be selected.</li>
    <li><code><a href="#isdeselectable">isDeselectable</a>: <b>true </b> | false</code><br />
        Allow an area to be click-deselected. When false, an area can be selected but not unselected by clicking.</li>
    <li><code><a href="#altImage">altImage</a>: <b>null</b> | 'path/to/image.png'</code><br />
        Use an alternate image of the same size as the imagemap as the source for highlight or select effects</li>
    <li>altImageOpacity: 0.7,</li>
    <li>fill: true,</li>
    <li>fillColor: '000000',</li>
    <li>fillColorMask: 'FFFFFF',</li>
    <li>fillOpacity: 0.5,</li>
    <li>stroke: false,</li>
    <li>strokeColor: 'ff0000',</li>
    <li>strokeOpacity: 1,</li>
    <li>strokeWidth: 1,</li>
    
</ul>

The following are <i>area-specific options</i> only (e.g. options defined in the <em>areas</em> array).

<ul>
    <li><code><a href="#showtooltip">includeKeys</a>: <b>null</b> | 'key1,key2,...'</code><br />
        A list of other areas, identified by key, that should be activated whenever this area is activated. </li>
    <li><code><a href="#ismask">isMask</a>: <b>false</b> | true</code><br />
        Identifies this area as a mask; that is, instead of being rendered, it will be exluded from a surrounding area.</li>
</ul>

<h4>Tooltip Options</h4>

<ul>
    <li><code><a href="#showtooltip">showToolTip</a>: <b>false</b> | true</code><br />
    enable tooltips for the image map</li>
    <li><code><a href="#tooltipcontainer">toolTipContainer</a>: <b>'&lt;div&gt; ... &lt;div&gt;</b> | html string | jQuery object</code><br />
        markup or jQuery object to wrap tooltips</li>
    <li><code><a href="#tooltip">toolTip</a>: <b>null</b> | html | jQuery object</code><br />
        (area-specific option) the content of the tooltip to be shown for this area</li>
  <li><code><a href="#tooltipclose">toolTipClose</a>: <b>['area-mouseout', ...]</b></code><br />
        define events that cause tooltips to close</li>
 
 </ul>

<h4>Events</h4>

The following are <i>events</i> or callbacks - these options can be assigned functions to handle specific input-driven events and
take action.

<ul>    
    <li><code><a href="#onclick">onClick</a>: <b>null</b> | function</code><br />callback when a hotspot area is clicked. Return false to cancel default select action, or true to navigate to the 'href'</li>
    <li><code><a href="#onmouseover">onMouseover</a>: <b>null</b> | function</code><br />callback when a hotspot is entered</li>
    <li><code><a href="#onmouseout">onMouseout</a>: <b>null</b> | function</code><br />callback when a hotspot is left</li>
    <li><code><a href="#ongetlist">onGetList</a>: <b>null</b> | function</code><br />callback on map binding containing area group data</li>
    <li><code><a href="#onconfigured">onConfigured</a>: <b>null</b> | function</code><br />
        callback when the map has finished intial binding/setup, and it is safe to call other methods</li>
    <li><code><a href="#onstatechange">onStateChange</a>: <b>null</b> | functon</code><br />
        callback when an area changes state, either highlight or select</li>
    <li><code><a href="#onshowtooltip">onShowToolTip</a>: function</code><br />callback when a tooltip is displayed</li>
</ul>
</div>

<div id="usage">
    <h2>Usage</h2>

    <p><strong>mapster</strong>: Bind to all selected images.</p>

    <pre><code>$('img').mapster(options);
    </code></pre>

    <p>All images in the jQuery object will be bound. The specific example above will attempt to bind to all images present on the page. Each image must be bound to an image map identified with the <code>usemap</code> attribute. If there is no <code>usemap</code> attribute, or it does not refer to a valid <code>map</code>, then the image will be ignored. Therefore you can use this syntax to activate all imagemaps on a page. Because pages often contain many images, though, it will be faster to select just the image you are targeting using a more specific selector.</p>

    <p>Images are often not completely loaded when script execution begins. ImageMapster will ensure that all images are loaded before it permits interaction from the client.  If an alternate image is specified, this will also be preloaded.</p>

    <p>Because images are loaded asynchronously, code execution will often return to your script before the ImageMapster is available. If you apply other methods to it (such as selecting or deselecting areas), these commands will be queued until the image has been loaded, and then executed automatically. So you don't need to worry about using callbacks for initial configuration. You can assign a function to a callback when configuration is complete if needed to perform other setup activities on the page.</p>
</div>
<div id="methods">
    <h2>Methods</h2>
    <a name="select"></a>
    <p><strong>select</strong>: Cause an area to become selected. This is similar to a user click, but will not cause a click event to be fired.</p>

    <pre><code>$('area').mapster('select');
    </code></pre>

    <p>Programatically select elements from the image map. The programmatic selection/deselection methods will not honor the staticState property.</p>

    <a name="deselect"></a>
    <p><strong>deselect</strong>: Cause an area to become deselected</p>

    <pre><code>$('area').mapster('deselect');
    </code></pre>
    <p>The opposite of <code>select</code>, this causes an area to become deselected. If it was not previously selected, nothing changes.</p>

    <a name="set"></a>
    <p><strong>set</strong>: select or deselect an area</p>

    <pre><code>$('area').mapster('set',selected,options);
    $('img').mapster('set',selected,key,options);
    ---    
    selected: (optional) bool _whether the area should be selected or deselected_. If missing or false, the area will be deselected.
    options: (optional) object _rendering options_. You can override the default rendering options by supplying an object with additional rendering options.
    </code></pre>

    <p>Select or deselect elements from jQuery objects wrapping "area" tags on the map based on truthiness of selected.
     If the area represents a bound area on the imagemap, it will be selected or deselected. The method can be called from an AREA, 
     or from a bound image, passing a specific key as a 2nd parameter</p>
     <p>If the <code>selected</code> parameter is omitted (or anything other than "true" or "false") then the state of each area will be toggled.</p>
      <p>You can include an object containing rendering options as the last parameter. When present, these will supercede the default and area-specific rendering options.</p>
    <a name="get"></a>

    <p><strong>get</strong>: get keys for all selected areas</p>

    <pre><code>$('img').mapster('get',key);
    ---
    key: (optional) string _a single mapKey identifying an area or area group_
    </code></pre>

    <p>When no "key" parameter is included, returns a comma-separated list of keys representing the areas 
    currently selected. If specified, returns true or false indicating whether the area specified is selected.</p>

    <a name="highlight"></a>
    <p><strong>highlight</strong>: highlight, clear, or return highlight state</p>

    <pre><code>$('img').mapster('highlight')        --&gt; returns map key of current highlighted area or null
    $('img').mapster('highlight',"key")  --&gt; highlight area identified by "key"
    $('img').mapster('highlight',false)  --&gt; remove highlight
    $('area').mapster('highlight');      --&gt; highlight 'area'
    </code></pre>

    <p>This method is used to control or obtain the current highlight state. Setting the highlight does not mimic a mouseover, rather, it only sets the highlight. Events and tooltips will not be activated. Even using these methods, it is not possible to highlight more than one area at a time. If another area is highlighted programatically, any existing highlight will be removed. </p>

    <p>Once set this way, the highlight will be removed when any user-event that would normally cause a highlight to be removed occurs (e.g. moving the mouse into any area), or it is removed programatically.</p>


     <a name="unbind"></a>
    <p><strong>unbind</strong>: unbind ImageMapster from an image</p>
    <pre><code>$('img').mapster('unbind');
    </code></pre>
    
    <p>Removes the ImageMapster binding from an image and restores it to its original state. All visible elements (selections, tooltips) will be removed.</p>

    <pre><code>$('img').mapster('unbind',preserveState);
    ---
    preserveState: bool _preserve the current state when unbinding including tooltips and selection overlay_
    </code></pre>

    <p>If the optional "preserveState" parameter is true, the selection overlay and any active tooltips will be preserved. Tooltips can still be dismissed by a user click, but once unbound, the selection states can no longer be controlled either by the user or programatically. To remove them, the actual DOM elements must be removed.</p>

    <p><em>Notes:</em> When a mapster is first bound, several things happen. A <code>div</code> element is created which wraps the image. 
    A copy is made of the original image, and the original image is set be transparent. This allows creating visible elements for the selections & highlights
    without interfering with the image map. Additionally, canvas elements are created (for HTML5 browsers), 
    or a VML elements are created for Internet Explorer, to render the effects. Profile information about each bound image map is stored in memory, and finally, 
    event handlers are bound to the image map.</p>

    <p>The "unbind" method cleans up these resources: it removes the wrapper, restores the image to its original visibility state, and releases internal
     resources. When using 'preserveState', the internal resources are cleaned up and event handling is disabled, but HTML elements are <em>not</em> 
     removed. Each element created by ImageMapster is assigned a class of "mapster_el", which can be used to target them for later removal, though it is not easy
     to complete this process manually because of the wrapper and styles applied during configuration, which will be left intact when using "preserveState."

     </p>

    <a name="snapshot"></a>
    <p><strong>snapshot</strong>: take a "snapshot" of the current selection state, and reset ImageMapster</p>

    <p>This option is similar to unbind with preserveState. After a snapshot, any active selections will still appear as they did at the time of the snapshot, but they are no longer part of the ImageMapster. This is useful for configuring an initial state, or creating complex representations that may not be easily accomplished with area configuration options.</p>

    <p>For example, you could bind in image with a specific set of options; programatically select some areas; and take a snapshot; then set new options that cause a different rendering mode. This way you could have certain areas appear differently from the selection highlight, but be "highlighted again" using the new rendering options. Any effects in place at the time of the snapshot essentially become part of the image and are not affected by future operations.</p>

    <a name="rebind"></a>
    <p><strong>rebind</strong>: rebind ImageMapster with new options</p>

    <pre><code>$('img').mapster('rebind',options);
    ---
    options: object _a JavaScript object containing ImageMapster options_
    </code></pre>
    <p>
    This method is similar to <code>set_options</code>, in that its purpose is to change options for an existing bound map. However, unlike
    <code>set_options</code> rebind will immediately apply all the new options to the existing map. This means that rendering options will change
    areas that are already selected to be rendered with the new options. If you pass area-specific options, these will also be applied, e.g. you could cause
    new areas to be selected by passing <code>selected: true</code> in an area specific options.
    </p><p>
    <code>set_options</code>, in contrast only changes the options, and does not apply them to any existing data. When using <code>set_options</code> the new
    options only apply to future actions.
    </p>

    <a name="resize"></a>
    <p><strong>resize</strong>: change the size of the image and map</p>

    <pre><code>$('img').mapster('resize',width,height,duration);
    ---
    image: new width of the image  OR
    height: new height of the image
    duration: (optional) 0 | milliseconds (to animate the resizing)
    </code></pre>

    <p>This will resize the image map to the dimensions specified. Note that <em>either</em> width or height should be passed, and the other will be calculated in the same aspect ratio as the original image. 
    If you pass both, only the width will be used to calculate the new dimensions: the proportions must remain the same as the original image.

    (Though I intend to allow scaling without constraining proportions, it will be difficult to make work for certain shapes -- e.g. circles, which would have to become ovals). </p>

    <p>This method will recalculate and re-render the entire imagemap, so it will work exactly the same under the new sizing scheme. When the image is unbound, the imagemap will be restored to its original condition.</p>

    <p>When using HTML5 canvases, any existing selections, etc. will be preserved during the animation. VML data cannot be resized dynamically, however, so in IE&lt;9 the selections will be erased, then redrawn when the animation is complete.</p>

    <a name="keys"></a>
    <p><strong>keys</strong>: get the primary mapKey (or comma-separated list of keys) for an area, set of areas, or key group. <i>Version 1.2.4.050</i></p>

    <pre><code>$('img').mapster('keys',key,all);
    $('area').mapster('keys',all);
    ---
    key: string _a single mapKey._ This is required when calling <code>keys</code> against an image.
    all: (optional) bool _when true, returns ALL keys and not just the primary keys.
    </code></pre>
    <p>
    This method allows you to obtain the primary <code>mapKey</code> (or keys) associated with another key,
    or one or more areas. If the <code>all</code> parameter is <code>true</code>, the method returns 
    <i>all keys or groups</i> that include the area. 
    </p>

    <p>
    When using area groups, it is possible for more than one key to be associated with a map area. It's also
    possible for an area to be highlighted from code as part of a group, but be inaccessible to the end-user. This is because
    area groups are <i>separate physical entities</i> from the areas defined by their primary key. They can
    have different options, and are highlighted independently. <i>Note: the way area groups work is not
    well documented here yet. I am working on a more comprehensive tutorial for the site. In the meantime please see
    <a href="http://jsfiddle.net/eaf2G/">this example</a> which describes area groups in detail, and shows how
    they work through an active demonstration.</i>
    </p>
    <p>
    There are reasons you may want to be able to access the primary keys that make up an area group directly.
    Perhaps you want to select a group of areas using the options from a group - but not as a separate group. 
    Perhaps you want to be able to compare the area clicked against a group you have defined to take some
    action if the area is a member of a certain group. This method provides access to that information. 
    </p>
    <p>This method allows working with groups in a variety of ways by providing access to a complete list of
    primary keys in any group, or all keys which contain a given primary key.</p>

    <a name="set_options"></a>
    <p><strong>set_options</strong>: set active options</p>

    <pre><code>$('img').mapster('set_options',options);
    ---
    options: object _a JavaScript object containing only options to be updated_
    </code></pre>

    <p>When called without the "options" parameter, returns an object with all active options. When the parameter is included, the active options are updated for the imagemap, and any area options are merged with existing area options. Unlike "rebind", this will not rebind or reapply any options, but only update the state. This may affect future actions, but it will not change any existing state information.</p>

    <a name="get_options"></a>
    <p><strong>get_options</strong>: get active options</p>

    <pre><code>$('img').mapster('get_options');
    $('img').mapster('get_options',key);
    $('img').mapster('get_options',key,effective);
    ---
    key: string _a single mapKey _
    effective: bool _when true, returns effective rather than assigned options_
    </code></pre>

    <p>When called with no parameters, returns the options that the mapster was configured using. When called with a single <code>key</code> it returns the area-specific options assigned to that area. The final parameter <code>effective</code> determines whether the actual options in effect for this area, or the specific options assigned are returned.</p>

    <p>Areas inherit the global options assigned, but can be overridden by area-specific options. The "effective" options contain all options including those that are inherited, as well as any specifically assigned to the area.</p>

    <a name="tooltip"></a>
    <p><strong>tooltip</strong>: show/hide tooltips from code</p>

    <pre><code>$('area').mapster('tooltip')        --&gt; activate tooltip bound to the applied area
    $('img').mapster('tooltip',"key")   --&gt; activate tooltip for area identified by "key"
    $('img').mapster('tooltip');        --&gt; remove active tooltip
    </code></pre>

    <p>
    See the <a href="#tooltip-options">tooltip options</a> section below for options to control how tooltips appear and are dismissed.
    </p>

    <p>This method can be used to manipulate tooltips from code. If the global <code>showToolTip</code> option is false, these methods will still work, so you have the ability to control tooltips bound to areas completely using your own logic, if desired. These methods can also be used to have better control over events needed to close the tooltip, e.g. you could have no tooltip closing event, but add a "close" button to your contianer that will cause the tooltip to close when clicked.</p>
    <a name="tooltip-end"></a>
</div>
<div id="options">
    <a name="areas"></a>
    <h2>Options and Area Options</h2>

    <p>Options can be assigned when creating a mapster in the usual jQuery plugin fashion as an object with each property representing 
    an option name and value. Some options can also be applied on a per-element basis (if it makes sense), e.g. any rendering options, 
    <em>selected</em>, <em>staticState</em>, <em>toolTip</em>. To apply options to an area, pass them as an array of objects in the 
    <em>areas</em> option, with a property called <em>key</em> that identifies the area for which these options should apply. The value of <em>key</em> should match one of the <em>keyValues</em> from the areas. For example, if two-letter state codes are used as keys, the following would cause Texas and Alabama to be selected initially:</p>


    <pre><code>$('#some_img').mapster({
        areas:  [{
               key: "TX", 
               toolTip: "Don't mess with Texas",
               selected: true
            },
            { 
               key: "AL",
               selected: true
            }]
    });
    </code></pre>

    <p><em>How to use this section</em></p>

    <p>Each option is shown in the following format:</p>

    <pre><code>optionName: defaultValue | other | values
    </code></pre>

    <p>That is, the first value shown is the default, and any other possible values are shown. If only specific values are permitted, then those values will be explicitly listed separated by a bar <code>|</code>. If any value of a particular type, e.g. <code>string</code> is allowed, then the type will be shown.</p>

    <h3>Area highlight/selection rendering options</h3>

    <p>The options below control the way highlighted areas are rendered. Each can be applied globally to the map, or to each element, using the <code>areas</code> option to pass area-specific options. These options apply to either <em>highlighted</em> or <em>selected</em> areas. Highlighting occurs when the mouse enters an area on the image map. Selection occurs when an area is clicked, and selection is enabled. These options will be applied to both situations if present in the root of the options object. They can also be applied to one or the other situations specifically using the <code>render_highlight</code> and <code>render_select</code> options. For example:</p>

    <pre><code>options={
        stroke: true,
        fillColor: '222222',
        render_highlight: {
            fillOpacity: 0.2
        },
        render_select: {
            fillOpacity: 0.8
        }
    }
    </code></pre>

    <p>The options for <code>stroke</code> and <code>fillColor</code> would be applied to both highlighting and selecting, but different fill opacities would apply to the two different situations. The options which apply are:</p>

    <pre><code>fill: true | false
    </code></pre>

    <p>Areas should be flood-filled when moused over or highlighted.</p>

    <div id="fill">
    <a name="fill"></a>
    <pre><code>fillColor: '000000'</code></pre>

    <p>The color used for flood fill.</p>

    <pre><code>fillOpacity: 0.2</code></pre>

    <p>The opacity of the fill. This is a number from 0 to 1.</p>
    </div>

    <div id="stroke">
    <a name="stroke"></a>

    <pre><code>stroke: true</code></pre>

    <p>Areas should be outlined when moused over or highlighted.</p>


    <pre><code>strokeColor: 'ff0000'</code></pre>

    <p>The color of the outline.</p>

    <pre><code>strokeOpacity: 1</code></pre>

    <p>The opacity of the outline.</p>

    <pre><code>strokeWidth: 1</code></pre>

    <p>The width of the outline.</p>
    </div>

    <div id="fade">
    <a name="fade"></a>
    <pre><code>fade: true</code></pre>

    <p>Use a fade effect when highlighting areas on mouseover.</p>

    <pre><code>fadeDuration: 150</code></pre>

    <p>The duration of the fade-in effect, in milliseconds.</p>
    </div>

    <a name="altImage"></a>
    <div id="altImage">
    <p><strong>altImage</strong>: an image to use as the source of the mouseover and highlight effect.</p>

    <pre><code>altImage: 'path/to/image.[gif|png|jpg]'</code></pre>

    <p>When specified, the mapster will highlight areas using the image data obtained from the same area in an alternate image, 
    instead of using a fill effect to highlight or select the area. This feature is currently available in browsers with HTML5 canvas support. In practical terms,
    this means it will work in all commonly used browsers except IE 8 or lower.
    <p>If this feature is enabled when an unsupported browser is used, it will fall back to the normal highlight method. </p>

    <p>The fill, stroke and opacity effects can be specified independently from those used for the normal higlight effect. This ensures
    that when your page is viewed with a non-supported browser, you can still control the rendering as would be appropriate for a normal
    fill/stroke effect, which may be different from when you're using an alternate image.</p>

    <pre><code>
    altImageFill: true,
    altImageStroke: false,
    altImageOpacity: 0.7
    </code></pre>

    <p>At this time, these are the only options that can be specified independently for alternate images from the normal highlighting options. 
    All other effect options will be shared by both highlight rendering methods (e.g. <code>strokeWidth</code>).</p>
    </div>

    <h3>Area selection state options</h3>

    <p>The following options determine behavior for areas.</p>

    <div id="selectable">
    <a name="isselectable"></a>
    <p><strong>isSelectable</strong>: the map or an area on the map can be selected (or deselected).</p>

    <pre><code>isSelectable: true | false
    </code></pre>

    <p>When true, the image map will function like a multiple-select menu. Users can click any area to select or deselect it. When applied to the entire map, it determines whether or not the click-selection functionality is enabled. When applied to an area, it determines whether that individual area (or group) can be selected. By default, the map and all areas are selectable.</p>

    <a name="isdeselectable"></a>
    <p><strong>isDeselectable</strong>: the map or area on the map can be deselected.</p>

    <pre><code>isDeselectable: true | false
    </code></pre>

    <p>Normally true, this option can be used to prevent users from unselecting items once they have been selected. When combined with <code>singleSelect</code>, the effect is that one and only one option can be selected at any given time. Users cannot deselect the active option. This provides a menu-like functionality. It is possible for zero items to be selected if this is the default state (or the only selected item is deselected programatically).</p>
    <p></p>
    </div>

    <a name="singleselect"></a>
    <p><strong>singleSelect</strong>: only one area can be selected at a time</p>

    <pre><code>singleSelect: false | true
    </code></pre>

    <p>When true, only one or zero areas can be selected at any given time. If an area is selected and the user selects another area, the previously selected area will become deselected.  Unlike "staticState", this property cannot be overridden by setting areas programatically, only one (or zero) areas can ever be selected when this option is true.</p>

    <a name="staticstate"></a>
    <p><strong>staticState</strong>: the map or area is permanently in a selected or deselected state.</p>

    <pre><code>staticState: null | true | false
    </code></pre>

    <p>When true or false, the map or area to which this option applies will be permanently selected or deselected. Typically this is more useful applied to individual areas that you want to exclude from the interactive part of the map.</p>

    <p><em>staticState</em> forces an area to be always selected or deselected. If set, this will supercede <em>isSelectable</em>. Something with a <em>staticState</em> will always be in that state and it cannot be changed by the user. Note that when setting states programatically, this option will not be honored; it only affects user interaction.</p>
    <a name="selected"></a>
    <p><strong>selected</strong>: initial selection state of an area.</p>

    <pre><code>selected: false | true
    </code></pre>

    <p>The area in question is selected. To set default selections when creating a new mapster, use this option for a specific area (see above).</p>

    <h3>Area grouping and metadata options</h3>

    <a name="mapkey"></a>
    <p><strong>mapKey</strong>: an attribute identifying each imagemap area. </p>

    <pre><code>mapKey: '' | string 
    </code></pre>

    <p>If specified, this refers to an attribute on the <code>area</code> tags that will be used to group them logically.
     Any areas containing the same <code>mapKey</code> will be considered part of a group, and rendered together when any of 
     these areas is activated. If you don't want this functionality, ensure each key is unique. When <code>mapKey</code> is omitted, 
     then each area is considered to be independent from the other and no grouping is applied.</p>

    <p>When <code>mapKey</code> is present, any <code>area</code> tags that are missing this attribute will be excluded from the image map e
    ntirely. This is functionally identical to setting <code>staticState=false</code> for these areas, except they will be inaccessible 
    through the API.</p>

    <p>ImageMapster will work with any attribute you identify as a key. If you wish to maintain HTML compliance, it's recommeded that you use
    attribute names starting with "data-", for example, <code>data-mapkey</code>. Any such names are legal for the HTML5 document type. If you are
    using older document types, the <code>class</code> attribute is part of the HTML spec for <code>area</code> and will not cause any 
    visual effects, so this is also a good choice. It is not recommended to use <code>id</code>, since the values of this attribute must be 
    unique. <code>title</code> and <code>alt</code> also will cause possibly undesired side effects.

    <p>You can specify more than one value in the <code>mapKey</code> attribute, separated by commas. This will cause an area to be a member of more 
    than one group. The area may have different options in the context of each group. When the area is physically moused over, the first key 
    listed will identify the group that's effective for that action. </p>

    <a name="mapvalue"></a>
    <p><strong>mapValue</strong>: an attribute on each <code>area</code> tag containing additional descriptive information about an area.</p>

    <pre><code>mapValue: '' | string | null
    </code></pre>

    <p>This option is applicable only when using <em>onGetList</em>. When set, the data provided to the callback function will include the value of this attribute for each group. This can be used to simplify building a list with associated information, without having to match against another resource. It also ties this information to the image map itself. It is not required to use this option when using <code>onGetList</code>.</p>

    <p>For example, you could set <code>mapValue: 'data-statename'</code> to an imagemap of the united states, and add an attribute to your areas that provided the full name of each state, e.g. <code>data-statename="Alaska"</code>. This text would be included in the <code>onGetList</code> callback, and so you could use it to construct an external list of states.</p>

    <p>If there are grouped areas (areas with the same key), then the value from the first area found with data in this attribute will be used.</p>

    <a name="includekeys"></a>
    <p><strong>includeKeys</strong>: when rendering an area or area group, also render the areas in the other group (or groups) specified</p>

    <pre><code>includeKeys: '' | 'group1,group2,...'          
    </code></pre>

    <p>This is an area-specific option that allows you to create supergroups. A supergroup is a collection of groups that will all be highlighted simultaneously, but only when the area that defines the supergroup is moused over or activated through code.</p>

    <p>When the area for which this option has been set is activated, all the areas specified in the <code>includeKeys</code> list will also be rendered. This is a one-way relationship. Defining a supergroup in an area causes all the other groups to be highlighted, but not the other way around. </p>

    <p>A typical use of this is to define areas that you want to be highlighted when the mouse enters some specific area, but that you do not want to be highlighted on their own if the target area is moused over. This could be a hidden menu, for example: you want the menu to display when the hotspot is moused over, but when it's hidden, mousing over the menu area itself should have no effect.</p>
    <a name="includekeys-end"></a>

    <a name="clicknavigate"></a>
    
    <p><strong>clickNavigate</strong>: Clicking on a link should cause the browser to navigate to the 
        <code>href</code> whenever it's not a hash sign (#). <i>Version 1.2.4.050 and later</i>
    </p>

    <pre><code>clickNavigate: false | true                   
    </code></pre>

    <p>
    By default, ImageMapster will prevent the default browser behavior in image maps, and "select" areas
    when they are clicked. If you want to navigate to the url for an area, use this option. When enabled,
    all areas that have an <code>href</code> attribute, and its value is not empty or "#" (just a hashtag). 
    </p>
    <p>
    When area grouping is used, if an <code>href</code> is present for <i>any</i> area in the primary group, 
    this will be used as the navigation target. This way you don't need to copy the url for every area in
    groups, rather, you can include it on just one, and clicking any area will cause the appropraite navigation.
    </p>

    <div id="masks">
    <a name="ismask"></a>
    <p><strong>isMask</strong>: the area is a mask rather than a highlighted area. </p>

    <pre><code>isMask: false | true                   
    </code></pre>

    <p>Normally, every area in an imagemap is an active area, and would be highlighted when moused over (unless its behavior was otherwise specified with <code>staticState</code>). The <code>isMask</code> option allows you to identify an area as being a mask. When a mask is part of an area group, the masked area will be specifically excluded from the rendering of a highlight or selected state.</p>

    <p>This is usually used in conjunction, or instead of, the <code>nohref</code> attribute of the area tag. When <code>nohref</code> is specified on an area tag, that area is specifically excluded from the hotspot of any area that encompasses it. It will not respond to mouse events, and will not be highlighted. This can be used to create "holes" in hotspots. By default, ImageMapster will treat any area with <code>nohref</code> or no <code>href</code> tag as masks, the same as if this option had been applied.</p>

    <p>Sometimes you won't be able to use <code>nohref</code> to identify something as a mask, for example, if you intend to re-use an area has both a mask, and an independent hotspot. This would be typical if you wanted to a selectable area that was completely included within another selectable area, but functioned independently, such as concentric circles. In this case, you would need to identify the inner circle as both a mask, and a hotspot. The <code>nohref</code> attribute would make it not act as a hotspot, and only function as a mask. You couldn't also select the inner area. You can solve this problem by including the inner circle in two different groups - one group which is a mask for the main area, and another which is an independent selectable area. You can specify different options for each group, so even though it's just one area, it can function as two completely independent ones. </p>

    <p>For example, the markup for two concentric circles, both of which are selectable, might look like:</p>

    <pre><code>&lt;area shape="circle" group="outer-circle" coords="100,81,59" href="#"&gt;
    &lt;area shape="circle" group="inner-circle,outer-circle-mask" coords="101,81,36" href="#"&gt;
    </code></pre>

    <p>the ImageMapster options would be:</p>

    <pre><code>{
        areas: [
            { key: "outer-circle",
              includeKeys: "outer-circle-mask"   // causes the mask to be included when this area is highlighted
            },
            {
                key: "outer-circle-mask",
                isMask: true                     // causes the inner circle to be treated as a mask, but only
                                                 // in the context of the "outer-circle-mask" group
            }
            // no special options needed for "inner-circle" - we want it to be treated normally on mouseover
        ];
    }
    </code></pre>

    <p>Please go to the <a href="http://www.outsharked.com/imagemapster/default.aspx?demos.html#shapes">shapes example</a> to see this in action.</p>

    <p>There may also be situations where you do not want an area marked with <code>nohref</code> to be treated as a mask. For example, given "area1" and "area2," you may want to create a configuration where mousing over "area1" causes both "area1" and "area2" to be highlighted, but "area2" should not be highlighted on its own when it is moused over. In this situation, you'll need to use "nohref" to prevent the hover behavior for the area, but you still want it to be treated normally when it's rendered as a result of mousing over "area1."  You can accomplish this using the <code>noHrefIsMask</code> global option, below.</p>

    <p>Generally, masked areas will appear as a window to the underlying image. If stroke is in effect, the stroke will be rendered for the mask as well as the areas, to create both inner and outer borders. You can always specifically enable or disable this, or any other effect, for any area as desired.</p>

    <a name="nohrefismask"></a>
    <p><strong>noHrefIsMask</strong>: Treat areas containing the <code>onhref</code> attribute (or missing the <code>href</code> attribute) as masks. This is true by default.</p>

    <pre><code>noHrefIsMask: true | false                  
    </code></pre>

    <p>Set this to "false" to disable automatic masking of these areas. You can control them explicitly by creating independent groups for areas you wish to mask and assigning the <code>isMask</code> area-specific option when using this option.</p>

    <p>There are some things to be aware of when using <code>nohref</code> and masking:</p>

    <ul>
    <li>You must put the <code>area</code> that include the <code>nohref</code> attribute before other areas that overlap it, or it will be ignored.</li>
    <li>You should also explicitly omit the <code>href</code> tag when using <code>nohref</code>.</li>
    <li>Due to limitations in rendering with VML (e.g. Internet Explorer 6-8), it is not possible to create a true mask, which would allow the underlying image to show through the masked area. Instead, the "masked" areas are rendered on top of the highlighted area in a different color. This can be specified for each area (see the <code>fillColorMask</code> option below) to create the best possible effect. </li>
    </ul>
    </div>
    <a name="scalemap"></a>
    <p><strong>scaleMap</strong>: Automatically scale imagemaps to match the size of a dynamically-scaled image.</p>
    <pre><code>scaleMap: <b>true</b> | false
    </code></pre>

    <p>When you render an image, you can optionally define a size through CSS or using the "height" and "width" attributes. If omitted, the image will be displayed in its native size. If included, browsers will automatically resize the image to display in the dimensions you have provided.</p>

    <p>Starting with 1.1.3, ImageMapster will automatically recalculate all <code>area</code> data to match the effective size of the image. This means that you can set the size of your image to anything you want and ImageMapster will work with no changes at all needed to the "area" data.</p>

    <p>If this behavior is not desired for some reason, this can be disabled by setting this option to false.</p>
    <a name="scalemap-end"></a>

    <h3>External list options</h3>

    <a name="boundlist"></a>
    <p><strong>boundList</strong>: a jQuery object whose elements are bound to the map.</p>

    <pre><code>boundList: null | jQuery-object
    </code></pre>

    <p>boundList can be any list of objects. To be bound to the map, they must contain an attribute whose name is identified by the option
         <em>listKey</em>, and whose value matches the value in an area tag's <em>mapKey</em> attribute. If more than one element in the list 
        has the same value, the action will affect all matching elements.</p>
    <p><a href="http://jsfiddle.net/jamietre/Pw5pg/">Example of using boundList</a></p>

    <a name="listkey"></a>
    <p><strong>listKey</strong>: an attribute on items in a <em>boundList</em> that corresponds to the value of the <em>mapKey</em> attributes.</p>

    <pre><code>listKey: 'value' | string
    </code></pre>

    <p>This is used to synchronize the actions on the imagemap with the actions on a boundList. Each value should match a value from the imageMap <em>mapKey</em> tag. Any item in the boundList with missing or mismatched data will be ignored.</p>

    <a name="listselectedattribute"></a>
    <p><strong>listSelectedAttribute</strong>: attribute to set or remove when an area is selected or deselected</p>


    <pre><code>listSelectedAttribute: 'selected' | null
    </code></pre>

    <p>If boundList is present, when a map area is selected, set or remove this attribute on the list element that matches that area based on their respective keys.</p>

     <a name="listselectedclass"></a>
    <p><strong>listSelectedClass</strong>: a class to add or remove when an area is selected or deselected</p>

    <pre><code>listSelectedClass: null | string
    </code></pre>

    <p>If a <code>boundList</code> is present, when a map area is selected, this class is added or removed from the corresponding list element. This can be used to easily create any kind of associated action when areas on the map are changed.</p>

    <a name="tooltip-options"></a>
    <h3>Tooltip options</h3>

    <div id="tooltips">
    <a name="showtooltip"></a>
    <p><strong>showToolTip</strong>: enable tooltips</p>

    <pre><code>showToolTip: false | true
    </code></pre>

    <p>When <code>showToolTip</code> is true, mapster will look for a property called <code>toolTip</code> in 
    the <code>areas</code> option for a an area. If present, a tool tip dialog will be shown on mouseover for that area. 
    It will automatically be closed according to the behavior specified by <code>toolTipClose</code>. 
    This option does not apply at the item level, but rather enables tooltips for the entire map. At the item level,
     only the presence of tooltip data is necessary for a tooltip to appear.</p>
     <p>Example option defining a tooltip for an area with key "TX":</p>
     <pre><code>$('#some_img').mapster({
        ...
        areas:  [{
               key: "TX", 
               toolTip: "Don't mess with Texas"
            }
        });
    </code></pre>

     <a name="tooltipcontainer"></a>
    <p><strong>toolTipContainer</strong>: HTML describing the popup that will be created for tooltips.</p>

    <pre><code>toolTipContainer: '&lt;div&gt; ... &lt;/div&gt;' | html string | jQuery object
    </code></pre>

    <p>A <code>div</code> with some simple styling is included as the default tooltip container. 
    This can be replaced with anything using this option.
    
    </p>

    <p>When tooltips are rendered, the code attempts to determine the best place for it. 
    It will try to position it in near the top-left part of the area, and continue to try other corners in 
    order to render it within the confines of the container where the image map resides. If it can't be placed within
    the image, it will be placed in the lower-right corner and extend outside the image.</p>

     <a name="tooltip"></a>
    <p><strong>toolTip</strong>: tool tip data for an area</p>

    <pre><code>toolTip: 'text' | jQuery object
    </code></pre>

    <p>When this area-specific option is present and showToolTips = true, a <em>toolTipContainer</em> will be created this will be inserted into it, either as inner text (if only text as passed) or as HTML if a jQuery object is passed. In order to pass anything other than plain text using this option you <em>must</em> use a jQuery object. Any string will be treated as plain text (and special characters rendered correctly).</p>

     <a name="tooltipclose"></a>
    <p><strong>toolTipClose</strong>: specify the behavior that causes a toolTip to close.</p>

    <pre><code>toolTipClose: ['area-mouseout', ...] | null
    </code></pre>

    <p>This option should be passed an array of strings that define the events that cause active tooltips to close. The array 
    can include one or more of the following stings:

    <ul>
        <li><b>'area-mouseout'</b> - tooltips close when the mouse pointer leaves the area that activated it. This is the default.</li>
        <li><b>'area-click'</b> - tooltips close when another area (or the same one) is clicked</li>
        <li><b>'tooltip-click'</b> - tooltips close when the tooltip itself is clicked anywhere</li>
        <li><b>'image-mouseout'</b> - tooltips close when the mouse pointer leaves the image itself.</li>
        
    </ul>
  
    <p>Under any circumstances, active tooltip will disappear when a new one is created. You don't have to define an automatic
    closing behavior; setting this option to an empty array will result in tooltips never closing, leaving it to you to close
    them manually though the <a href="#tooltip">tooltip</a> method.<p>

     <a name="onshowtooltip"></a>
    <p><strong>onShowToolTip</strong>: callback when a toolTip is created</p>

    <pre><code>onShowToolTip: null | function
    </code></pre>

    <p>This will call a function when a tooltip is shown, with the following data:</p>

    <pre><code>function showToolTipHandler(data) {
         // this = area element bound to the tooltip
          //data = {
                toolTip: jQuery object of the tooltip container
                areaOptions: { area_options },
                key: map key for this area,
                selected: true | false - current state of the area
         };
    } 
    </code></pre>

    <p>This can be used to control tooltip closing behavior directly, if desired.</p>
    </div>
    <a name="mouseoutdelay"></a>
    <p><strong>mouseoutDelay</strong>: delay removing highlight when mouse exits an area <i>(1.2.5b36)</i></p>
    <pre><code>mouseoutDelay: 0 | -1 | n (milliseconds)
    </code></pre>
    <p>Normally, when the user's mouse pointer exits an area, the highlight effect is removed immediately. This behavior can be changed
    with this option. Setting it to a positive number causes a delay of <i>n</i> milliseconds before the effect is removed. Setting to -1
    causes the effect to remain active until another hotspot is entered (e.g., it will only be removed when superceded by a
    different area being highlighted). 
    </p>
    <p>When using <em>mouseoutDelay</em>, the onMouseover event will still be fired at the time the user's mouse pointer leaves the area.
    However, the <em>onStateChange</em> event will be delayed until the highlight is actually removed.</p>
    <p><i>Whether or not you are using <code>mouseoutDelay</code>, only one area can be highlighted at a time.</i> That is, whenever the mouse pointer
    moves onto a new active area, any previously highlighted area will become un-highlighted, regardless of any delay in effect. Hovering over a new
    area will always supercede any delay and cause the new area (and only the new area) to be highlighted at that time. So, for dense imagemaps where
    most areas adjoin one another, this option may not have much effect within the boundaries of the imagemap. 
    Rather, it is intended to help keep the higlights active for imagemaps that are sparse,
    or have very small areas.
    
    
    </p>
     <a name="mouseoutdelayend"></a>

    <h3>Callbacks and events</h3>

    <a name="onconfigured"></a>
    <p><strong>onConfigured</strong>: a callback when the mapster has finished initial configuration</p>

    <pre><code>onConfigured(success): null | function
    --
    this: mapster bound image
    success: true or false
    </code></pre>

    <p>This event is fired when the mapster configuration completes. When control execution continues after a 
    first-time bind operation, the mapster is not guaranteed to be configured, because images are loaded 
    asynchronously by web browsers. If a mapster is bound to an image that is not yet loaded, it will attempt 
    to rebind every 200 milliseconds. This event will be fired when it is eventually successful, or the length 
    of time specified by <code>configTimeout</code> is exceeded (default of ten seconds).</p>

    <p>The <code>altImage</code> option will also increase the time needed to configure, because the alternate image is loaded by the client at configure time to ensure it is available immediately when needed.</p>

    <a name="onclick"></a>
    <p><strong>onClick</strong>: a callback when an area is clicked. </p>

    <pre><code>onClick(data): null | function
    </code></pre>

    <p>This event occurs when the usual <code>click</code> event happens, but includes data from the mapster about the area:</p>

    <pre><code>function clickHandler(data) {
        //this = area element clicked
        //data = {
            e: jQuery eventObject
            listTarget: $(item) from boundList
            key: mapKey for this area
            selected: true | false
        };
    }
    </code></pre>

    <p>This can be used to perform additional actions on a click without binding another event and having to obtain information manually.</p>
    <a name="onstatechange"></a>

    <p><strong>onStateChange</strong>: callback when area state is changed (either highlight or select).</p>

    <pre><code>onStateChange: function({
                                key: (string) map key,
                                state: (string) "highlight" | "select",
                                selected: (bool) true or false, indicating the current state (following the event)
                              }
    </code></pre>

    <p>onStateChange can be used to get more specific information than the mouseover or click events.</p>

    <a name="onmouseover"></a>

    <p><strong>onMouseover</strong>: callback when mouse enters a bound area.</p>

    <pre><code>onMouseover: null | function
    </code></pre>

    <p>This function is called when the mouse enters a bound area. The function passes a parameter of the following structure:

    </p>

    <pre><code>
    {
        e: object,             // jQuery event object
        options: object  ,     // object of area-specific options
        key: 'string',         // area key
        selected: bool         // true if area is currently selected
    }
    </code>
    </pre>

    <a name="onmouseout"></a>
    <p><strong>onMouseout</strong>: callback when mouse leavesd a bound area.</p>
    <pre><code>onMouseout: null | function
    </code></pre>

    <p>Callback when the mouse leaves a bound area. The data structure passed to the callback is the same as onMouseover.</p>

    <a name="ongetlist"></a>
    <p><strong>onGetList</strong>: a callback on mapster initialization that provides summary data about the image map, and expects a jQuery list to be returned.</p>

    <pre><code>onGetList: null | function
    </code></pre>

    <p>This callback allows you to dynamically provide a boundList based on summary data from the imagemap itself, rather than providing the list up front. 
    The event passes an array of <code>AreaData</code> objects, of the following structure:

    <pre><code>
    { 
       key: 'key',       // primary mapKey for this area or area group
       value: 'value',   // mapValue for this area or group
       options = {}      // area-specific options defined for this group.
       areas = []        // array of areas that make up this group
    }
    </code>
    </pre>

    The client should return a jQuery object containing all the elements that make up the bound list,
    the same as if it was assigned manually. Typical function structure is as follows:</p>

    <pre><code>function getListHandler(data) {
        for (var i=0;i&lt;data.length;i++) {
            element = ... // create an HTML element using data[i].key &amp; data[i].value 
            myListContainer.append(element);
        }
        // do not return the container - only the actual elements that make up the list
        return myListContainer.children();
    }
    </code></pre>

    <p>The client should return a jQuery object containing all the elements that make up the bound list,
    the same as if it was assigned manually. Typical function structure is as follows:</p>


    <a name="sortlist"></a>
    <p><strong>sortList</strong>: sort the values before calling <em>onGetList</em></p>

    <pre><code>sortList: false | 'asc' | 'desc'
    </code></pre>

    <p>If a non-false value or "asc" is passed, the list will be sorted in ascending order by the area value from <em>mapValue</em>. 
If "desc" is passed, the list will be sorted in descending order.</p>

    <a name="configtimeout"></a>
    <p><strong>configTimeout</strong>: time (in milliseconds) to wait for images to load before giving up</p>

    <pre><code>configTimeout: <b>10000</b> | integer
    </code></pre>

    <p>When first bound, ImageMapster has to wait for the source image,and any <code>altImage</code> images to load before it
    can finish binding. This is necessary because otherwise it's not alwasy possible to know the native size of the images.
    After this period of time, ImageMapster will give up. If you have particularly large pages or images, 
    you may want to increase this to account for long load times.
</div>
    </div>
  </div>
  
  
  </div>

</div>
</div>