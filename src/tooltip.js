/*
  tooltip.js
  Tooltip functionality
  Requires areacorners.js
*/

(function ($) {
  'use strict';

  var m = $.mapster,
    u = m.utils;

  $.extend(m.defaults, {
    toolTipContainer:
      '<div style="border: 2px solid black; background: #EEEEEE; width:160px; padding:4px; margin: 4px; -moz-box-shadow: 3px 3px 5px #535353; ' +
      '-webkit-box-shadow: 3px 3px 5px #535353; box-shadow: 3px 3px 5px #535353; -moz-border-radius: 6px 6px 6px 6px; -webkit-border-radius: 6px; ' +
      'border-radius: 6px 6px 6px 6px; opacity: 0.9;"></div>',
    showToolTip: false,
    toolTip: null,
    toolTipFade: true,
    toolTipClose: ['area-mouseout', 'image-mouseout', 'generic-mouseout'],
    onShowToolTip: null,
    onHideToolTip: null
  });

  $.extend(m.area_defaults, {
    toolTip: null,
    toolTipClose: null
  });

  /**
   * Show a tooltip positioned near this area.
   *
   * @param {string|jquery} html A string of html or a jQuery object containing the tooltip content.
   * @param {string|jquery} [template] The html template in which to wrap the content
   * @param {string|object} [css] CSS to apply to the outermost element of the tooltip
   * @return {jquery} The tooltip that was created
   */

  function createToolTip(html, template, css) {
    var tooltip;

    // wrap the template in a jQuery object, or clone the template if it's already one.
    // This assumes that anything other than a string is a jQuery object; if it's not jQuery will
    // probably throw an error.

    if (template) {
      tooltip =
        typeof template === 'string' ? $(template) : $(template).clone();

      tooltip.append(html);
    } else {
      tooltip = $(html);
    }

    // always set display to block, or the positioning css won't work if the end user happened to
    // use a non-block type element.

    tooltip
      .css(
        $.extend(css || {}, {
          display: 'block',
          position: 'absolute'
        })
      )
      .hide();

    $('body').append(tooltip);

    // we must actually add the tooltip to the DOM and "show" it in order to figure out how much space it
    // consumes, and then reposition it with that knowledge.
    // We also cache the actual opacity setting to restore finally.

    tooltip.attr('data-opacity', tooltip.css('opacity')).css('opacity', 0);

    // doesn't really show it because opacity=0

    return tooltip.show();
  }

  /**
   * Show a tooltip positioned near this area.
   *
   * @param {jquery} tooltip The tooltip
   * @param {object} [options] options for displaying the tooltip.
   *  @config {int} [left] The 0-based absolute x position for the tooltip
   *  @config {int} [top] The 0-based absolute y position for the tooltip
   *  @config {string|object} [css] CSS to apply to the outermost element of the tooltip
   *  @config {bool} [fadeDuration] When non-zero, the duration in milliseconds of a fade-in effect for the tooltip.
   */

  function showToolTipImpl(tooltip, options) {
    var tooltipCss = {
        left: options.left + 'px',
        top: options.top + 'px'
      },
      actalOpacity = tooltip.attr('data-opacity') || 0,
      zindex = tooltip.css('z-index');

    if (parseInt(zindex, 10) === 0 || zindex === 'auto') {
      tooltipCss['z-index'] = 9999;
    }

    tooltip.css(tooltipCss).addClass('mapster_tooltip');

    if (options.fadeDuration && options.fadeDuration > 0) {
      u.fader(tooltip[0], 0, actalOpacity, options.fadeDuration);
    } else {
      u.setOpacity(tooltip[0], actalOpacity);
    }
  }

  /**
   * Hide and remove active tooltips
   *
   * @param  {MapData} this The mapdata object to which the tooltips belong
   */

  m.MapData.prototype.clearToolTip = function () {
    if (this.activeToolTip) {
      this.activeToolTip.stop().remove();
      this.activeToolTip = null;
      this.activeToolTipID = null;
      u.ifFunction(this.options.onHideToolTip, this);
    }
  };

  /**
   * Configure the binding between a named tooltip closing option, and a mouse event.
   *
   * If a callback is passed, it will be called when the activating event occurs, and the tooltip will
   * only closed if it returns true.
   *
   * @param  {MapData}  [this]     The MapData object to which this tooltip belongs.
   * @param  {String}   option     The name of the tooltip closing option
   * @param  {String}   event      UI event to bind to this option
   * @param  {Element}  target     The DOM element that is the target of the event
   * @param  {Function} [beforeClose] Callback when the tooltip is closed
   * @param  {Function} [onClose]  Callback when the tooltip is closed
   */
  function bindToolTipClose(
    options,
    bindOption,
    event,
    target,
    beforeClose,
    onClose
  ) {
    var tooltip_ns = '.mapster.tooltip',
      event_name = event + tooltip_ns;

    if ($.inArray(bindOption, options) >= 0) {
      target.off(event_name).on(event_name, function (e) {
        if (!beforeClose || beforeClose.call(this, e)) {
          target.off(tooltip_ns);
          if (onClose) {
            onClose.call(this);
          }
        }
      });

      return {
        object: target,
        event: event_name
      };
    }
  }

  /**
   * Show a tooltip.
   *
   * @param {string|jquery}   [tooltip]       A string of html or a jQuery object containing the tooltip content.
   *
   * @param {string|jquery}   [target]        The target of the tooltip, to be used to determine positioning. If null,
   *                                          absolute position values must be passed with left and top.
   *
   * @param {string|jquery}   [image]         If target is an [area] the image that owns it
   *
   * @param {string|jquery}   [container]     An element within which the tooltip must be bounded
   *
   * @param {object|string|jQuery} [options]  options to apply when creating this tooltip
   *  @config {int}           [offsetx]       the horizontal amount to offset the tooltip
   *  @config {int}           [offsety]       the vertical amount to offset the tooltip
   *  @config {string|object} [css]           CSS to apply to the outermost element of the tooltip
   *  @config {bool}          [fadeDuration]  When non-zero, the duration in milliseconds of a fade-in effect for the tooltip.
   *  @config {int}           [left]          The 0-based absolute x position for the tooltip (only used if target is not specified)
   *  @config {int}           [top]           The 0-based absolute y position for the tooltip (only used if target it not specified)
   */

  function showToolTip(tooltip, target, image, container, options) {
    var corners,
      ttopts = {};

    options = options || {};

    if (target) {
      corners = u.areaCorners(
        target,
        image,
        container,
        tooltip.outerWidth(true),
        tooltip.outerHeight(true)
      );

      // Try to upper-left align it first, if that doesn't work, change the parameters

      ttopts.left = corners[0];
      ttopts.top = corners[1];
    } else {
      ttopts.left = options.left;
      ttopts.top = options.top;
    }

    ttopts.left += options.offsetx || 0;
    ttopts.top += options.offsety || 0;

    ttopts.css = options.css;
    ttopts.fadeDuration = options.fadeDuration;

    showToolTipImpl(tooltip, ttopts);

    return tooltip;
  }

  /**
     * Show a tooltip positioned near this area.
      *
     * @param {string|jquery|function}   [content] A string of html, jQuery object or function that returns same containing the tooltip content.

     * @param {object} [options]  options to apply when creating this tooltip
     *  @config {string|jquery} [container]     An element within which the tooltip must be bounded
     *  @config {bool}          [template]      a template to use instead of the default. If this property exists and is null,
     *                                          then no template will be used.
     *  @config {string}        [closeEvents]   A string with one or more comma-separated values that determine when the tooltip
     *                                          closes: 'area-click','tooltip-click','image-mouseout','image-click' are valid values
     *                                          then no template will be used.
     *  @config {int}           [offsetx]       the horizontal amount to offset the tooltip
     *  @config {int}           [offsety]       the vertical amount to offset the tooltip
     *  @config {string|object} [css]           CSS to apply to the outermost element of the tooltip
     *  @config {bool}          [fadeDuration]  When non-zero, the duration in milliseconds of a fade-in effect for the tooltip.
     */
  m.AreaData.prototype.showToolTip = function (content, options) {
    var tooltip,
      closeOpts,
      target,
      tipClosed,
      template,
      ttopts = {},
      ad = this,
      md = ad.owner,
      areaOpts = ad.effectiveOptions();

    // copy the options object so we can update it
    options = options ? $.extend({}, options) : {};

    content = content || areaOpts.toolTip;
    closeOpts =
      options.closeEvents ||
      areaOpts.toolTipClose ||
      md.options.toolTipClose ||
      'tooltip-click';

    template =
      typeof options.template !== 'undefined'
        ? options.template
        : md.options.toolTipContainer;

    options.closeEvents =
      typeof closeOpts === 'string'
        ? (closeOpts = u.split(closeOpts))
        : closeOpts;

    options.fadeDuration =
      options.fadeDuration ||
      (md.options.toolTipFade
        ? u.isNumeric(areaOpts.fadeDuration)
          ? areaOpts.fadeDuration
          : md.options.fadeDuration
        : 0);

    target = ad.area
      ? ad.area
      : $.map(ad.areas(), function (e) {
          return e.area;
        });

    if (md.activeToolTipID === ad.areaId) {
      return;
    }

    md.clearToolTip();

    var effectiveContent = u.isFunction(content)
      ? content({ key: this.key, target: target })
      : content;

    if (!effectiveContent) {
      return;
    }

    md.activeToolTip = tooltip = createToolTip(
      effectiveContent,
      template,
      options.css
    );

    md.activeToolTipID = ad.areaId;

    tipClosed = function () {
      md.clearToolTip();
    };

    bindToolTipClose(
      closeOpts,
      'area-click',
      'click',
      $(md.map),
      null,
      tipClosed
    );
    bindToolTipClose(
      closeOpts,
      'tooltip-click',
      'click',
      tooltip,
      null,
      tipClosed
    );
    bindToolTipClose(
      closeOpts,
      'image-mouseout',
      'mouseout',
      $(md.image),
      function (e) {
        return (
          e.relatedTarget &&
          e.relatedTarget.nodeName !== 'AREA' &&
          e.relatedTarget !== ad.area
        );
      },
      tipClosed
    );
    bindToolTipClose(
      closeOpts,
      'image-click',
      'click',
      $(md.image),
      null,
      tipClosed
    );

    showToolTip(tooltip, target, md.image, options.container, options);

    u.ifFunction(md.options.onShowToolTip, ad.area, {
      toolTip: tooltip,
      options: ttopts,
      areaOptions: areaOpts,
      key: ad.key,
      selected: ad.isSelected()
    });

    return tooltip;
  };

  /**
   * Parse an object that could be a string, a jquery object, or an object with a "contents" property
   * containing html or a jQuery object.
   *
   * @param  {object|string|jQuery} options The parameter to parse
   * @return {string|jquery} A string or jquery object
   */
  function getHtmlFromOptions(options) {
    // see if any html was passed as either the options object itself, or the content property

    return options
      ? typeof options === 'string' || options.jquery || u.isFunction(options)
        ? options
        : options.content
      : null;
  }

  function getOptionsFromOptions(options) {
    return options
      ? typeof options == 'string' || options.jquery || u.isFunction(options)
        ? { content: options }
        : options
      : {};
  }

  /**
   * Activate or remove a tooltip for an area. When this method is called on an area, the
   * key parameter doesn't apply and "options" is the first parameter.
   *
   * When called with no parameters, or "key" is a falsy value, any active tooltip is cleared.
   *
   * When only a key is provided, the default tooltip for the area is used.
   *
   * When html is provided, this is used instead of the default tooltip.
   *
   * When "noTemplate" is true, the default tooltip template will not be used either, meaning only
   * the actual html passed will be used.
   *
   * @param  {string|AreaElement|HTMLElement} key The area key or element for which to activate a tooltip, or a DOM element/selector.
   *
   * @param {object|string|jquery} [options] options to apply when creating this tooltip - OR -
   *                                         The markup, or a jquery object, containing the data for the tooltip
   *  @config {string|jQuery|function} [content] the inner content of the tooltip; the tooltip text, HTML or function that returns same
   *  @config {Element|jQuery} [container] the inner content of the tooltip; the tooltip text or HTML
   *  @config {bool}           [template] a template to use instead of the default. If this property exists and is null,
   *                                      then no template will be used.
   *  @config {string}         [closeEvents] A string with one or more comma-separated values that determine when the tooltip
   *                                         closes: 'area-click','tooltip-click','image-mouseout','image-click','generic-click','generic-mouseout' are valid values
   *  @config {int}            [offsetx] the horizontal amount to offset the tooltip.
   *  @config {int}            [offsety] the vertical amount to offset the tooltip.
   *  @config {string|object}  [css] CSS to apply to the outermost element of the tooltip
   *  @config {bool}           [fadeDuration] When non-zero, the duration in milliseconds of a fade-in effect for the tooltip.
   * @return {jQuery} The jQuery object
   */

  m.impl.tooltip = function (key, options) {
    return new m.Method(
      this,
      function mapData() {
        var tooltip,
          target,
          defaultTarget,
          closeOpts,
          tipClosed,
          md = this;
        if (!key) {
          md.clearToolTip();
        } else {
          target = $(key);
          defaultTarget = target && target.length > 0 ? target[0] : null;
          if (md.activeToolTipID === defaultTarget) {
            return;
          }

          md.clearToolTip();
          if (!defaultTarget) {
            return;
          }

          var content = getHtmlFromOptions(options),
            effectiveContent = u.isFunction(content)
              ? content({ key: this.key, target: target })
              : content;

          if (!effectiveContent) {
            return;
          }

          options = getOptionsFromOptions(options);

          closeOpts =
            options.closeEvents || md.options.toolTipClose || 'tooltip-click';

          options.closeEvents =
            typeof closeOpts === 'string'
              ? (closeOpts = u.split(closeOpts))
              : closeOpts;

          options.fadeDuration =
            options.fadeDuration ||
            (md.options.toolTipFade ? md.options.fadeDuration : 0);

          tipClosed = function () {
            md.clearToolTip();
          };

          md.activeToolTip = tooltip = createToolTip(
            effectiveContent,
            options.template || md.options.toolTipContainer,
            options.css
          );
          md.activeToolTipID = defaultTarget;

          bindToolTipClose(
            closeOpts,
            'tooltip-click',
            'click',
            tooltip,
            null,
            tipClosed
          );

          bindToolTipClose(
            closeOpts,
            'generic-mouseout',
            'mouseout',
            target,
            null,
            tipClosed
          );

          bindToolTipClose(
            closeOpts,
            'generic-click',
            'click',
            target,
            null,
            tipClosed
          );

          md.activeToolTip = tooltip = showToolTip(
            tooltip,
            target,
            md.image,
            options.container,
            options
          );
        }
      },
      function areaData() {
        if ($.isPlainObject(key) && !options) {
          options = key;
        }

        this.showToolTip(
          getHtmlFromOptions(options),
          getOptionsFromOptions(options)
        );
      },
      {
        name: 'tooltip',
        args: arguments,
        key: key
      }
    ).go();
  };
})(jQuery);
